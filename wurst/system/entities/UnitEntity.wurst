package UnitEntity

// Standard library imports
import ClosureTimers
import HashMap
import UnitIndexer
import ClosureEvents

// Third party library
import Lodash

import SpawnDataConstant

// The entity corresponding to each unit.
let instances = new HashMap<unit, UnitEntity>()

// The UnitEntity corresponding to each type ID.
let factories = new HashMap<int, Function<unit, UnitEntity>>()

public abstract class UnitEntity
    static function register(int unitTypeId, Function<unit, thistype> factory)
        factories.put(unitTypeId, factory)

    static function findForUnit(unit whichUnit) returns thistype
        if instances.has(whichUnit)
            return instances.get(whichUnit)
        else
            return null

    static function onDeath(unit target)
        // Look up the entity for the dying unit.
        let entity = UnitEntity.findForUnit(target)

        // Fire the event, as necessary.
        if entity != null
            entity.onDeath()

    static function onRevive(unit target)
        // Look up the entity for the reviving unit.
        let entity = UnitEntity.findForUnit(target)

        // Fire the event, as necessary.
        if entity != null
            entity.onRevive()

    static function onIndex(unit target)
        // Exit if the unit was already assigned an entity.
        if UnitEntity.findForUnit(target) != null
            return

        // Look up the factory for the type.
        let factory = factories.get(target.getTypeId())

        // Exit if the unit is not registered within the entity framework.
        if factory == null
            return

        // Create the entity.
        factory.call(target)

    private unit theUnit
    private boolean giveBounty = true

    construct(unit whichUnit)
        theUnit = whichUnit
        postCreate()

    function postCreate()
        instances.put(theUnit, this)

    function getUnit() returns unit
        return theUnit

    function getPos() returns vec2
        return theUnit.getPos()

    function giveBounty()
        let killerOwner = EventData.getKillingUnit().getOwner()
        let unitKilled = EventData.getTriggerUnit()
        var _bounty = 0
        let unitCap = spawnDataConstant.get(unitKilled.getTypeId()).unitCap

        if killerOwner != players[PLAYER_NEUTRAL_AGGRESSIVE]
            _bounty = (unitKilled.getPointValue() / (3 * unitCap)).floor()

            if giveBounty
                killerOwner.addGold(_bounty)
                createTTEx(
                    unitKilled.getPos3Real(),
                    "+" + _bounty.toString(),
                    10,
                    colorA(255,220,0,255),
                    killerOwner
                )
                ..setVelocity(0.0, 0.03)
                ..setFadepoint(1.5)
                ..setLifespan(2.0)
                ..setPermanent(false)
        // TODO: handle increase bounty on naga secret upgd?
        // Bounty for tower
        // bounty for summons
        // checkout gold factor


    function onRevive()
        postRevive()

    function postRevive()

    function onDeath()
        giveBounty()
        postDeath()

    function postDeath()
        nullTimer(-> destroy this)



    ondestroy
        instances.remove(theUnit)

init
    EventListener.add(EVENT_PLAYER_UNIT_DEATH) ->
        UnitEntity.onDeath(GetDyingUnit())
    EventListener.add(EVENT_PLAYER_HERO_REVIVE_FINISH) ->
        UnitEntity.onRevive(GetRevivingUnit())

    onUnitIndex() ->
        // Cache the state for later use.
        let target = getIndexingUnit()

        // Wait for the unit to finish being indexed.
        nullTimer() ->
            UnitEntity.onIndex(target)
