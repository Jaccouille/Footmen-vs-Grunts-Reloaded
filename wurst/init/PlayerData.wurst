package PlayerData

import HashMap
import ClosureTimers
import ClosureEvents

import Indicators


/**
    Player Value is the percent of gain compared to the total gain in the game
    total gain = sum of all player gain
    playerGain = playerGain + bounty from kills (killer)
    playerFeed = playerFeed + bounty from kills (victim)
    playerValue = 100 * playerGain / total gain
**/
public class PlayerData
    private static let playerDataMap = new HashMap<player, PlayerData>
    static function initialize()
        for i = 0 to 10
            // TODO: remove on release
            // if players[i].isIngame()
            new PlayerData(players[i])

        replaceIndicator()

    static function getPlayerData(player _player) returns PlayerData
        if playerDataMap.has(_player)
            return playerDataMap.get(_player)
        return null

    static function removePlayerData(player _player)
        if playerDataMap.has(_player)
            playerDataMap.remove(_player)


    player _player
    let playerBuilding = new IterableMap<int, unit>
    real playerIncome = 5.
    real playerValue = 0
    int playerGain = 0
    int playerFeed = 0
    // tax used to compute lumber bounty
    // the higher the player value, the lower the tax
    real goldFactorTax = 1

    construct(player _player)
        this._player = _player
        playerDataMap.put(_player, this)

    function addBuilding(unit building)
        // Make sure the hashMap is empty
        // For some god only knows reason, player 5 already has building
        // but trying to get them result in wc3 crashing
        if playerBuilding.has(building.getTypeId())
            playerBuilding.remove(building.getTypeId())

        playerBuilding.put(building.getTypeId(), building)
        EventListener.add(building, EVENT_PLAYER_UNIT_DEATH) ->
            playerBuilding.remove(building.getTypeId())
            unregisterEventsForUnit(building)

    function getIncome() returns real
        return this.playerIncome

    function setIncome(real income)
        this.playerIncome = income

    function addIncome(real income)
        this.playerIncome += income

    function getGain() returns int
        return this.playerGain

    function setGain(int gain)
        this.playerGain = gain

    function getFeed() returns int
        return this.playerFeed

    function setFeed(int feed)
        this.playerFeed = feed

    function getGoldFactorTax() returns real
        return this.goldFactorTax

    function setGoldFactorTax(real goldFactorTax)
        this.goldFactorTax = goldFactorTax

    function getPlayerValue() returns real
        return this.playerValue

    // playerValue = 100 * playerGain / total gain
    // playerValue is the value of the player in the game compared to the rest
    // of the player, the value is used to adjust taxes, the lower the
    // playerValue, the lesser the taxes, this is a tiny helping hand for
    // player who are behind
    // TODO: Update player value periodically with the scoreboard
    function setPlayerValue(real playerValue)
        this.playerValue = playerValue

    function updateTaxRate()
        // set total_gain=player_gain[10]+player_gain[11]
        // This linear equation is taken from Compit's Footmen vs Grunts
        // if playerValue > 40, tax = 0.6
        // if playerValue == 0, tax = 1
        this.setGoldFactorTax(this.playerValue * (- 1 / 100) + 1)


// It's easier to place units on editor and then replace them with our
// Wurst defined units
function replaceIndicator()
    // Delay to ensure that all indicators are registered prior to execution.
    nullTimer() ->
        // Replace indicators one type at a time.
        indicators.forEach() (integer originID, integer targetID) ->
            // Find all matching indicators for the current type.
            ENUM_GROUP..clear().enumUnitsOfType(originID, null)

            // Replace each indicator with the corresponding unit.
            for origin in ENUM_GROUP
                // Extract the relevant information from the indicator.
                let owner = origin.getOwner()
                let pos   = origin.getPos()
                let angle = origin.getFacingAngle()

                // Remove the indicator once it is no longer needed.
                origin.remove()

                // Create the actual unit.
                let target = createUnit(owner, targetID, pos, angle)
                // TODO: add condition before accesing map
                if target.getOwner().getId() < 10
                    let pData = PlayerData.getPlayerData(target.getOwner())
                    pData.addBuilding(target)

                // TODO : for some reason this following code
                // crashes due to HotkeyMapping definition in CommonUtils.wurst
                // Find out why
                // Look up the callbacks for this indicator.
                // if indicatorCallbacks.has(targetID)
                //     let list = indicatorCallbacks.get(targetID)

                //     // Execute each callback, as necessary.
                //     if list != null
                //         list.forEach() (Callback cb) ->
                //             cb.run(target)


init
    EventListener.add(EVENT_PLAYER_LEAVE) ->
        let _player = EventData.getTriggerPlayer()
        destroy PlayerData.getPlayerData(_player)
        PlayerData.removePlayerData(_player)
